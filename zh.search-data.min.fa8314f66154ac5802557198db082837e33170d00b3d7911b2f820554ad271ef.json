[{"id":0,"href":"/menu/","title":"Menu","section":"Cangaroo自整理开发文档","content":" 首页 Window SetupDialog类 Core Backend类 CanTrace类 Driver CanListener类 "},{"id":1,"href":"/docs/core/Backend_class/","title":"Backend类","section":"core文件夹","content":" Backend类 # 此类继承自 QObject类\n成员函数 # 公共成员函数 # static Backend \u0026amp;instance()\nvoid addCanDriver(CanDriver \u0026amp;driver)\nbool startMeasurement()\nvoid stopMeasurement()\nbool isMeasurementRunning() const\ndouble getTimestampAtMeasurementStart() const\nuint64_t getUsecsAtMeasurementStart() const\nuint64_t getNsecsSinceMeasurementStart() const\nuint64_t getUsecsSinceMeasurementStart() const\nvoid logMessage(const QDateTime dt, const log_level_t level, const QString msg)\nMeasurementSetup \u0026amp;getSetup()\nvoid loadDefaultSetup(MeasurementSetup \u0026amp;setup)\nvoid setDefaultSetup()\nvoid setSetup(MeasurementSetup \u0026amp;new_setup)\ndouble currentTimeStamp() const\nCanTrace *getTrace()\nvoid clearTrace()\nCanDbMessage *findDbMessage(const CanMessage \u0026amp;msg) const\nCanInterfaceIdList getInterfaceList()\nCanDriver *getDriverById(CanInterfaceId id)\nCanInterface *getInterfaceById(CanInterfaceId id)\nQString getInterfaceName(CanInterfaceId id)\nQString getDriverName(CanInterfaceId id)\nCanDriver *getDriverByName(QString driverName)\nCanInterface *getInterfaceByDriverAndName(QString driverName, QString deviceName)\npCanDb loadDbc(QString filename)\nvoid clearLog()\nLogModel \u0026amp;getLogModel() const\n信号 # void beginMeasurement()\nvoid endMeasurement()\nvoid onSetupChanged()\nvoid onLogMessage(const QDateTime dt, const log_level_t level, const QString msg)\nvoid onSetupDialogCreated(SetupDialog \u0026amp;dlg)\n公共成员函数说明 # instance # static Backend \u0026amp;instance() 静态函数，被调用时，会检查私有成员变量_instance是否为空(0)。\n若为空，则创建一个Backend对象，赋值给_instance并返回。\n否则，直接返回现有的Backend实例。\n返回值：Backend类的实例的引用\naddCanDriver # void addCanDriver(CanDriver \u0026amp;driver) 添加一个Can驱动\nstartMeasurement # bool startMeasurement() 调用该函数会从事先设置*的网络(network)和接口(interface)列表中， 依次获取网络及其中的Can接口，并分别启动一个新线程监听获取到的每个Can接口。\n正常情况下，函数会发出beginMeasurement信号，并返回true。\n*事先设置：通常是用户通过 SetupDialog设定的\nstopMeasurement # void stopMeasurement() 调用此函数会向每一个监听线程发送停止请求，等待所有线程退出后，函数返回。\n正常情况下，函数会发出endMeasurement信号，并返回true。\nisMeasurementRunning # bool isMeasurementRunning() const 如果测量正在运行,返回true,否则返回false。\ngetTimestampAtMeasurementStart # double getTimestampAtMeasurementStart() const 返回测量开始时的时间戳。\ngetUsecsAtMeasurementStart # uint64_t getUsecsAtMeasurementStart() const 返回测量开始时的微秒数。\ngetNsecsSinceMeasurementStart # uint64_t getNsecsSinceMeasurementStart() const 返回测量开始后经过的纳秒数。\ngetUsecsSinceMeasurementStart # uint64_t getUsecsSinceMeasurementStart() const 返回测量开始后经过的微秒数。\nlogMessage # void logMessage(const QDateTime dt, const log_level_t level, const QString msg) 将日志消息添加到日志模型(LogModel)中。具体实现是发送onLogMessage信号。\n参数：\ndt: 日志消息的时间 level: 日志消息的级别 msg: 日志消息的内容 getSetup # MeasurementSetup \u0026amp;getSetup() 返回测量设置(MeasurementSetup)。具体实现是返回私有成员变量_setup。\nloadDefaultSetup # void loadDefaultSetup(MeasurementSetup \u0026amp;setup) 加载默认设置到参数setup指定的MeasurementSetup对象中（尚未清楚何谓默认设置）。\nsetDefaultSetup # void setDefaultSetup() 相当于调用loadDefaultSetup(_setup)。\nsetSetup # void setSetup(MeasurementSetup \u0026amp;new_setup) 把参数new_setup中的设置应用到私有成员变量_setup中。\ncurrentTimeStamp # double currentTimeStamp() const 返回当前时间戳（单位：毫秒）。\ngetTrace # CanTrace *getTrace() 返回私有成员变量_trace。（目前未研究Cantrace类）\nclearTrace # void clearTrace() 清除私有成员变量_trace。（目前未研究Cantrace类）\nfindDbMessage # CanDbMessage *findDbMessage(const CanMessage \u0026amp;msg) const 未研究Canmeasurement类\ngetInterfaceList # CanInterfaceIdList getInterfaceList() 返回当前的接口(Interface)列表。\ngetDriverById # CanDriver *getDriverById(CanInterfaceId id) 返回指定id的Interface对应的Can驱动。如果不存在，属于严重错误\ngetInterfaceById # CanInterface *getInterfaceById(CanInterfaceId id) 返回指定id的Interface，如果不存在则返回0。\ngetInterfaceName # QString getInterfaceName(CanInterfaceId id) 返回指定id的接口(interface)的名称。如果不存在则返回空字符串，属于严重错误（试图获取不存在的接口的名称）。\ngetDriverName # QString getDriverName(CanInterfaceId id) 返回指定id的接口(interface)的驱动(driver)的名称。如果不存在则返回空字符串。\ngetDriverByName # CanDriver *getDriverByName(QString driverName) 返回指定名称的Can驱动。如果不存在则返回0。\ngetInterfaceByDriverAndName # CanInterface *getInterfaceByDriverAndName(QString driverName, QString deviceName) 在指定名称的driver中查找指定名称的Interface,并返回其名称。如果不存在则返回0。\nloadDbc # pCanDb loadDbc(QString filename) 从指定的dbc数据库中加载数据并返回。\nclearLog # void clearLog() 清除日志模型(LogModel)中的所有日志。\ngetLogModel # LogModel \u0026amp;getLogModel() const 返回私有成员变量_logModel指向的内存地址的内容。\n"},{"id":2,"href":"/docs/driver/CanListener_class/","title":"CanListener类","section":"driver文件夹","content":" CanListener类 # 此类继承自 QObject类\n成员函数 # 公共成员函数 # CanInterfaceId getInterfaceId()\nCanInterface \u0026amp;getInterface()\n槽函数 # void run()\nvoid startThread()\nvoid requestStop()\nvoid waitFinish()\n公共成员函数说明 # getInterfaceId # CanInterfaceId getInterfaceId() 返回所监听的接口(Interface)的ID。\ngetInterface # CanInterface \u0026amp;getInterface() 返回所监听的接口(Interface)。\n公共槽函数说明 # run # void run() 循环从所监听的接口(Interface)读取数据并输出到trace(尚未研究CanTrace)，直至全部数据读取完毕\nstartThread # void startThread() 把当前CanListener关联到一个新的线程并启动，启动后执行run()函数\nrequestStop # void requestStop() 设置停止标志*，会使run()函数停止读取数据并退出\n*停止标志：在run()函数中会检查此标志，若为真则退出\nwaitFinish # void waitFinish() 设置停止标志并等待进程停止\n*停止标志：在run()函数中会检查此标志，若为真则退出\n"},{"id":3,"href":"/docs/core/CanTrace_class/","title":"CanTrace类","section":"core文件夹","content":" CanListener类 # 此类继承自 QObject类\n成员函数 # 公共成员函数 # unsigned long size()\nvoid clear()\nconst CanMessage *getMessage(int idx)\nvoid enqueueMessage(const CanMessage \u0026amp;msg, bool more_to_follow=false)\nvoid saveCanDump(QFile \u0026amp;file)\nvoid saveVectorAsc(QFile \u0026amp;file)\nbool getMuxedSignalFromCache(const CanDbSignal *signal, uint64_t *raw_value)\n公共成员函数说明 # size # unsigned long size() 返回已占用的行数(?)\nclear # void clear() 清空trace\ngetMessage # const CanMessage *getMessage(int idx) 返回指定行的CanMessage，若idx超出范围则返回0(nullptr)\nenqueueMessage # void enqueueMessage(const CanMessage \u0026amp;msg, bool more_to_follow=false) 把msg加入trace，如果more_to_follow为false，则执行 startTimer()\nsaveCanDump # void saveCanDump(QFile \u0026amp;file) 把trace中数据保存到文件\nsaveVectorAsc # void saveVectorAsc(QFile \u0026amp;file) 把trace中数据保存到为asc向量文件(?)。此函数中有很多未完成部分\ngetMuxedSignalFromCache # bool getMuxedSignalFromCache(const CanDbSignal *signal, uint64_t *raw_value) 从缓存中获取信号，保存到raw_value中，若缓存中存在且成功获取则返回true，否则返回false\n"},{"id":4,"href":"/docs/core/","title":"core文件夹","section":"Docs","content":" 信息 # 本程序的核心部分\n包含的类 # Backend # \u0026ldquo;后端\u0026quot;类，用于和测量仪器交互(?)\nCanTrace # 保存从Can接口或数据库获取的数据\n"},{"id":5,"href":"/docs/","title":"Docs","section":"Cangaroo自整理开发文档","content":""},{"id":6,"href":"/docs/driver/","title":"driver文件夹","section":"Docs","content":" 信息 # 和设备交互的代码\n包含的类 # CanListener类\n监听Can接口\n"},{"id":7,"href":"/docs/window/SetupDialog_class/","title":"SetupDialog类","section":"window文件夹","content":" SetupDialog类 # 此类继承自 QDialog类\n成员函数 # 公共成员函数 # bool showSetupDialog(MeasurementSetup \u0026amp;setup)\nvoid addPage(QWidget *widget)\nvoid displayPage(QWidget *widget)\n信号 # void onShowInterfacePage(SetupDialog \u0026amp;dlg, MeasurementInterface *mi)\n槽函数 # 公共槽函数 # void treeViewSelectionChanged(const QItemSelection \u0026amp; selected, const QItemSelection \u0026amp; deselected)\nvoid treeViewContextMenu(const QPoint\u0026amp; pos)\n公有成员函数说明 # showSetupDialog # bool showSetupDialog(MeasurementSetup \u0026amp;setup) 被调用时会显示设置窗口\n参数：\nsetup：MeasurementSetup类的引用 返回值：用户点击确定(ok)按钮关闭窗口返回true，其它情况返回false\naddPage # void addPage(QWidget *widget) 未知（猜测：和显示接口列表的框有关） 观察：程序启动时此函数会被执行多次\ndisplayPage # void displayPage(QWidget *widget) 未知（猜测：和显示接口列表的框有关）\n信号说明 # onShowInterfacePage # void onShowInterfacePage(SetupDialog \u0026amp;dlg, MeasurementInterface *mi) 调试过程中未观察到此信号的发出\n槽函数说明 # treeViewSelectionChanged # void treeViewSelectionChanged(const QItemSelection \u0026amp; selected, const QItemSelection \u0026amp; deselected) 根据传入的两个参数的类型，在窗口右侧显示相应的设置页面。\n调试过程中发现：当用户在窗口左侧列表选择项目时会触发此槽函数。\ntreeViewContextMenu # void treeViewContextMenu(const QPoint\u0026amp; pos) 调试过程中未观察到此槽函数的触发。\n猜测和窗口显示的位置有关。\n"},{"id":8,"href":"/docs/window/","title":"window文件夹","section":"Docs","content":" 信息 # 用户界面的各类窗口\n包含的类 # SetupDialog # 测量设置窗口\n"},{"id":9,"href":"/docs/misc/","title":"其它开发内容","section":"Docs","content":""}]